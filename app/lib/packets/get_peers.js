// Generated by CoffeeScript 1.6.3
(function() {
  var bencoding, ip_ntoa, peerAddress;

  bencoding = require('bencoding');

  ip_ntoa = function(ip) {
    return (ip & 255) + '.' + ((ip >> 8) & 255) + '.' + ((ip >> 16) & 255) + '.' + ((ip >> 24) & 255);
  };

  peerAddress = function(peer) {
    var address, ip, parts;
    parts = peer.address.split('.');
    ip = (parseInt(parts[3], 10) << 24) >>> 0;
    ip += (parseInt(parts[2], 10) << 16) >>> 0;
    ip += (parseInt(parts[1], 10) << 8) >>> 0;
    ip += parseInt(parts[0], 10) >>> 0;
    address = new Buffer(6);
    address.writeUInt32LE(ip, 0);
    address.writeUInt16LE(peer.port, 4);
    return address;
  };

  module.exports = function(server, rpeer, packet) {
    var answer, lpeer, peer, peerIdentifierHex, share, shareHashHex, _, _ref;
    peerIdentifierHex = packet.peer.toString('hex');
    shareHashHex = packet.share.toString('hex');
    rpeer = {
      address: rpeer.address,
      port: rpeer.port
    };
    lpeer = {
      address: ip_ntoa(packet.la.readUInt32LE(0)),
      port: packet.la.readUInt16LE(2)
    };
    server.log.debug('Received packet: get_peers');
    server.log.debug('> Peer identifier: ' + peerIdentifierHex);
    server.log.debug('> Share hash: ' + shareHashHex);
    server.log.debug('> Local peer address: ' + lpeer.address + ':' + lpeer.port);
    server.log.debug('> Remote peer address: ' + rpeer.address + ':' + rpeer.port);
    if (server.trackerData[shareHashHex] != null) {
      server.log.debug('Found existing share announcement: ' + shareHashHex);
      share = server.trackerData[shareHashHex];
    } else {
      server.log.log('New share announced: ' + shareHashHex);
      share = server.trackerData[shareHashHex] = {
        createdAt: new Date(),
        updatedAt: null,
        peers: {}
      };
    }
    share.updatedAt = new Date();
    if (share.peers[peerIdentifierHex] != null) {
      peer = share.peers[peerIdentifierHex];
    } else {
      peer = share.peers[peerIdentifierHex] = {
        createdAt: new Date(),
        updatedAt: null,
        id: packet.peer,
        rpeer: null,
        lpeer: null
      };
    }
    peer.updatedAt = new Date();
    peer.rpeer = [rpeer, peerAddress(rpeer)];
    peer.lpeer = [lpeer, peerAddress(lpeer)];
    answer = {
      m: 'peers',
      share: packet.share,
      time: Math.round((new Date()).getTime() / 1000),
      ea: peer.rpeer[1],
      peers: []
    };
    _ref = share.peers;
    for (_ in _ref) {
      peer = _ref[_];
      answer.peers.push({
        p: peer.id,
        a: peer.rpeer[1],
        la: peer.lpeer[1]
      });
    }
    return server.send(answer, rpeer);
  };

}).call(this);
