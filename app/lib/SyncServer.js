// Generated by CoffeeScript 1.6.3
(function() {
  var SyncServer, bencoding, dgram,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  dgram = require('dgram');

  bencoding = require('bencoding');

  module.exports = SyncServer = (function() {
    var PACKET_HEADER;

    PACKET_HEADER = new Buffer([66, 83, 89, 78, 67, 0]);

    function SyncServer(_app) {
      this._app = _app;
      this._onSocketMessage = __bind(this._onSocketMessage, this);
      this._onSocketError = __bind(this._onSocketError, this);
      this._socket = dgram.createSocket('udp4');
      this._socket.on('error', this._onSocketError);
      this._socket.on('message', this._onSocketMessage);
    }

    SyncServer.prototype._onSocketError = function(err) {
      return this._app.getLogger().error('Socket error: ' + (typeof err.toString === "function" ? err.toString() : void 0));
    };

    SyncServer.prototype._onSocketMessage = function(packet, peer) {
      var packetData, packetHeader, packetPayload, _ref;
      _ref = this._parsePacketHeader(packet), packetHeader = _ref[0], packetPayload = _ref[1];
      packetData = bencoding.decode(packetPayload);
      if (packetData.length !== 0) {
        return this._app.getTracker().handlePacket(packetData.toJSON(), peer);
      } else {
        return this._app.getLogger().warning('Relay server not yet implemented. Packet discarded.');
      }
    };

    SyncServer.prototype._parsePacketHeader = function(packet) {
      var packetHeader, packetPayload;
      packetHeader = packet.slice(0, PACKET_HEADER.length);
      packetPayload = packet.slice(PACKET_HEADER.length);
      if (!packetHeader.toString('hex') === PACKET_HEADER.toString('hex')) {
        this._app.getLogger().debug('Expected packet header: ' + PACKET_HEADER.toString('hex'));
        this._app.getLogger().debug('Received packet header: ' + packetHeader.toString('hex'));
        this._app.getLogger().warning('Discarded packet with invalid header.');
      }
      return [packetHeader, packetPayload];
    };

    SyncServer.prototype.listen = function(port, address) {
      this._socket.bind(port, address);
      return this._app.getLogger().info('Sync server listening on ' + address + ':' + port);
    };

    SyncServer.prototype.sendAnswer = function(answerData, peer) {
      var packet, packetPayload;
      packetPayload = bencoding.encode(answerData);
      packet = new Buffer(PACKET_HEADER.length + packetPayload.length);
      PACKET_HEADER.copy(packet);
      packetPayload.copy(packet, PACKET_HEADER);
      return this._socket.send(packet, 0, packet.length, peer.port, peer.address);
    };

    return SyncServer;

  })();

}).call(this);
